MAXIMUM DEPTH OF BINARY TREE
package com.abc.trees;

class TreeNode
{
	int value;
	TreeNode leftNode;
	TreeNode rightNode;
	
	public TreeNode(int value) {
		super();
		this.value = value;
		this.leftNode = null;
		this.rightNode = null;
	}
	
	public static int findMaxDepth(TreeNode rootNode)
	{

//		Base Conditionm
		if(rootNode == null)
		{
			return 0;
		}
		
		int leftValue = TreeNode.findMaxDepth(rootNode.leftNode);
		int rightValue = TreeNode.findMaxDepth(rootNode.rightNode);
		
		return Math.max(leftValue, rightValue) + 1;
	}
	
	
}


public class FirstExample {

	public static void main(String[] args) {
		
		TreeNode rootNode = new TreeNode(1);
		TreeNode secondNode = new TreeNode(2);
		TreeNode thirdNode = new TreeNode(3);
		TreeNode fourthNode = new TreeNode(4);
		TreeNode fifthNode = new TreeNode(5);
		TreeNode sixthNode = new TreeNode(6);
		TreeNode seventhNode = new TreeNode(7);

		
		rootNode.leftNode = secondNode;
		rootNode.rightNode = thirdNode;
		
		secondNode.leftNode = fourthNode;
		secondNode.rightNode = fifthNode;
		
		thirdNode.leftNode = sixthNode;
		thirdNode.rightNode = seventhNode;
		
		
		int maxDepth = TreeNode.findMaxDepth(rootNode);
		System.out.println(maxDepth);
	}

}

==========================
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {

        if(root == null)
        {
            return 0;
        }

        int depth = 0;

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.add(root);

        while(!queue.isEmpty())
        {
            for(int i = 0; i < queue.size(); i++)
            {
                TreeNode readEleNode = queue.poll();
                // readElement = Node(3)
                if(readEleNode.left != null)
                {
                    queue.add(readEleNode.left);
                }
                if(readEleNode.right != null)
                {
                    queue.add(readEleNode.right);
                }
            }
            depth++;
        }		

        return depth;
        
    }
}
===============
SAME TREE
 Queue<TreeNode> queue = new LinkedList<>();
        queue.add(p);
        queue.add(q);

        while (!queue.isEmpty()) {
            TreeNode node1 = queue.poll();
            TreeNode node2 = queue.poll();

            // ✅ Case 1: both nodes are null
            // That means both subtrees are empty at this position → so continue checking next nodes
            if (node1 == null && node2 == null) {
                continue;
            }

            // ✅ Case 2: one node is null but the other is not
            // That means one tree ended earlier → so they are different
            if (node1 == null && node2 != null) {
                return false;
            }

            if (node1 != null && node2 == null) {
                return false;
            }

            // ✅ Case 3: both are non-null but have different values
            if (node1.val != node2.val) {
                return false;
            }

            // ✅ Case 4: both are non-null and have same value
            // → add their children to queue for further comparison
            queue.add(node1.left);
            queue.add(node2.left);
            queue.add(node1.right);
            queue.add(node2.right);
        }

        // ✅ If the loop ends without finding any mismatch
        // That means both trees are identical
        return true;
====================================================
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
       
       if( p == null && q == null)
       {
            return true;
       }

       if( (p != null && q == null)
       || 
       ( p == null && q != null)
       || ( p.val != q.val) )
       {
            return false;
       }

       boolean leftResult = isSameTree(p.left, q.left);
       boolean rightResult = isSameTree(p.right, q.right);

      return leftResult && rightResult;
        

    }
}
