


Problem: Set Matrix Zeroes
LeetCode 73

 🔹 Problem Statement

Given an `m x n` matrix, if an element is `0`, set its entire row and column to `0`.
Do it in place (no extra matrix allowed).

 🔹 Example

Input:

```
[
 [1,1,1],
 [1,0,1],
 [1,1,1]
]
```

Output:

```
[
 [1,0,1],
 [0,0,0],
 [1,0,1]
]
```



 🔹 Intuition

* We can’t change cells immediately because it affects other checks.
* So:

  1. First pass → mark rows and columns to zero using first row/col as flags.
  2. Second pass → set elements to zero based on those flags.



 🔹 Java Solution

```java
public class SetMatrixZeroes {
    public static void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean firstRow = false, firstCol = false;

        // Step 1: Mark zeros in first row/column
        for (int i = 0; i < m; i++)
            if (matrix[i][0] == 0) firstCol = true;

        for (int j = 0; j < n; j++)
            if (matrix[0][j] == 0) firstRow = true;

        // Step 2: Mark zeros in first row/column for rest
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        // Step 3: Set zeros based on markers
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            }
        }

        // Step 4: Handle first row & column
        if (firstRow)
            for (int j = 0; j < n; j++) matrix[0][j] = 0;

        if (firstCol)
            for (int i = 0; i < m; i++) matrix[i][0] = 0;
    }

    public static void main(String[] args) {
        int[][] matrix = {{1,1,1},{1,0,1},{1,1,1}};
        setZeroes(matrix);
        for (int[] row : matrix) System.out.println(java.util.Arrays.toString(row));
    }
}
```



 🔹 Trace

1️⃣ Found `matrix[1][1] == 0` → mark `matrix[1][0] = 0`, `matrix[0][1] = 0`
2️⃣ Update all where marker row/column = 0

✅ Result:

```
[1,0,1]
[0,0,0]
[1,0,1]
```



Problem: Rotate Image (Matrix)
LeetCode 48

 🔹 Problem Statement

Rotate the given square matrix by 90° clockwise, in place.

 🔹 Example

Input:

```
[
 [1,2,3],
 [4,5,6],
 [7,8,9]
]
```

Output:

```
[
 [7,4,1],
 [8,5,2],
 [9,6,3]
]
```



 🔹 Intuition

Two steps:

1. Transpose the matrix (rows ↔ columns)
2. Reverse each row



 🔹 Java Solution

```java
public class RotateImage {
    public static void rotate(int[][] matrix) {
        int n = matrix.length;

        // Step 1: Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // Step 2: Reverse each row
        for (int[] row : matrix) {
            for (int i = 0, j = n - 1; i < j; i++, j--) {
                int temp = row[i];
                row[i] = row[j];
                row[j] = temp;
            }
        }
    }

    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        rotate(matrix);
        for (int[] row : matrix) System.out.println(java.util.Arrays.toString(row));
    }
}
```



 🔹 Trace

After Transpose:

```
[1,4,7]
[2,5,8]
[3,6,9]
```

After Row Reverse:

```
[7,4,1]
[8,5,2]
[9,6,3]
```

✅ Output = Rotated 90° clockwise.



Problem: Product of Array Except Self
LeetCode 238



 🔹 Problem Statement

Given an array `nums`, return an array `answer` such that:

```
answer[i] = product of all elements of nums except nums[i]
```

Do it without using division and in O(n) time.



 🔹 Example

Input:
`nums = [1,2,3,4]`
Output:
`[24,12,8,6]`

Explanation:
For index 0 → 2×3×4 = 24
For index 1 → 1×3×4 = 12
...



 🔹 Intuition

* Left product: product of all before i
* Right product: product of all after i
  → Multiply both.



 🔹 Java Solution

```java
import java.util.Arrays;

public class ProductExceptSelf {
    public static int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] output = new int[n];
        int[] left = new int[n];
        int[] right = new int[n];

        left[0] = 1;
        for (int i = 1; i < n; i++)
            left[i] = left[i - 1] * nums[i - 1];

        right[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--)
            right[i] = right[i + 1] * nums[i + 1];

        for (int i = 0; i < n; i++)
            output[i] = left[i] * right[i];

        return output;
    }

    public static void main(String[] args) {
        System.out.println(Arrays.toString(productExceptSelf(new int[]{1,2,3,4})));
    }
}
```



 🔹 Trace

```
nums = [1,2,3,4]
left  = [1,1,2,6]
right = [24,12,4,1]
output= [24,12,8,6]
```

✅ Output → `[24,12,8,6]`



Problem: Longest Repeating Character Replacement
LeetCode 424



 🔹 Problem Statement

Given a string `s` and integer `k`, you can change at most `k` characters to any letter.
Find the length of the longest substring containing the same letter after performing the replacements.



 🔹 Example

Input:
`s = "AABABBA"`, `k = 1`
Output:
`4`

Explanation:
Replace one `'B'` → `"AAAA"` (length 4).



 🔹 Intuition

Sliding window:

* Track count of characters in the current window.
* Check if `(window length - maxFreq) <= k`
  → means we can still replace within k.



 🔹 Java Solution

```java
public class LongestRepeatingReplacement {
    public static int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int left = 0, maxCount = 0, maxLength = 0;

        for (int right = 0; right < s.length(); right++) {
            count[s.charAt(right) - 'A']++;
            maxCount = Math.max(maxCount, count[s.charAt(right) - 'A']);

            while ((right - left + 1) - maxCount > k) {
                count[s.charAt(left) - 'A']--;
                left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }
        return maxLength;
    }

    public static void main(String[] args) {
        System.out.println(characterReplacement("AABABBA", 1)); // Output: 4
    }
}
```



 🔹 Trace

| Window | Length | maxCount | (len - maxCount) | Replace OK? |
|  |  | -- | - | -- |
| A      | 1      | 1        | 0                | ✅           |
| AA     | 2      | 2        | 0                | ✅           |
| AAB    | 3      | 2        | 1                | ✅           |
| AABA   | 4      | 3        | 1                | ✅           |
| AABAB  | 5      | 3        | 2                | ❌ shrink    |

✅ Max length = 4


 Problem: Minimum Window Substring
LeetCode 76



 🔹 Problem Statement

Given two strings `s` and `t`, find the smallest substring in `s` that contains all characters of `t`.



 🔹 Example

Input:
`s = "ADOBECODEBANC"`, `t = "ABC"`
Output:
`"BANC"`



 🔹 Intuition

Sliding window + frequency count:

1. Expand `right` until all chars of `t` are included.
2. Then shrink `left` to minimize window.



 🔹 Java Solution

```java
import java.util.*;

public class MinimumWindowSubstring {
    public static String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";

        Map<Character, Integer> need = new HashMap<>();
        for (char c : t.toCharArray())
            need.put(c, need.getOrDefault(c, 0) + 1);

        int left = 0, right = 0, required = need.size();
        int formed = 0;
        Map<Character, Integer> window = new HashMap<>();
        int[] ans = {-1, 0, 0}; // length, left, right

        while (right < s.length()) {
            char c = s.charAt(right);
            window.put(c, window.getOrDefault(c, 0) + 1);

            if (need.containsKey(c) && window.get(c).intValue() == need.get(c).intValue())
                formed++;

            while (left <= right && formed == required) {
                if (ans[0] == -1 || right - left + 1 < ans[0])
                    ans = new int[]{right - left + 1, left, right};

                char ch = s.charAt(left);
                window.put(ch, window.get(ch) - 1);
                if (need.containsKey(ch) && window.get(ch) < need.get(ch))
                    formed--;
                left++;
            }
            right++;
        }

        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }

    public static void main(String[] args) {
        System.out.println(minWindow("ADOBECODEBANC", "ABC")); // Output: BANC
    }
}
```



 🔹 Trace

```
Expand → "ADOBEC" contains A,B,C
Shrink → smallest is "BANC"
```

✅ Output: `"BANC"`


Problem: 3Sum (LeetCode 15)
 Problem Statement

Given an integer array `nums`, find all unique triplets `[nums[i], nums[j], nums[k]]`
such that:

```
nums[i] + nums[j] + nums[k] == 0
```

You must not use the same index twice, and the result must not contain duplicates.



 🔹 Example

Input:

```
nums = [-1, 0, 1, 2, -1, -4]
```

Output:

```
[[-1, -1, 2], [-1, 0, 1]]
```

Explanation:

* (-1) + (-1) + 2 = 0
* (-1) + 0 + 1 = 0
  No other combinations sum to zero.



 🔹 Intuition

We need triplets that sum to 0.

1. Sort the array → makes it easier to skip duplicates.
2. Fix one number → `nums[i]`.
3. Use two pointers (`left`, `right`) to find two other numbers whose sum = `-nums[i]`.



 🔹 Java Solution

```java
import java.util.*;

public class ThreeSum {
    public static List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums); // Step 1: sort array
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicate fixed numbers
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1;
            int right = nums.length - 1;

            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];

                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // Move both pointers, skipping duplicates
                    left++;
                    right--;
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;

                } else if (sum < 0) {
                    left++; // need bigger number
                } else {
                    right--; // need smaller number
                }
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int[] nums = {-1, 0, 1, 2, -1, -4};
        System.out.println(threeSum(nums));
    }
}
```



 🔹 Step-by-Step Trace

Input (sorted):

```
nums = [-4, -1, -1, 0, 1, 2]
```

| Step | i         | nums[i] | left           | right | sum                                         | Action               |
| - |  | - | -- | -- | - | -- |
| 1    | 0         | -4      | 1              | 5     | (-4)+(-1)+2 = -3                            | sum < 0 → left++     |
| 2    | 0         | -4      | 2              | 5     | (-4)+(-1)+2 = -3                            | left++               |
| 3    | 0         | -4      | 3              | 5     | (-4)+0+2 = -2                               | left++               |
| 4    | 0         | -4      | 4              | 5     | (-4)+1+2 = -1                               | left++ (end of loop) |
| 5    | 1         | -1      | 2              | 5     | (-1)+(-1)+2 = 0 ✅ Found triplet [-1, -1, 2] |                      |
| 6    | 1         | -1      | 3              | 4     | (-1)+0+1 = 0 ✅ Found triplet [-1, 0, 1]     |                      |
| 7    | 1         | -1      | (no more)      | -     | -                                           | end                  |
| 8    | 2         | -1      | skip duplicate | -     | -                                           | continue             |
| 9    | 3         | 0       | 4              | 5     | 0+1+2=3                                     | right--              |
| 10   | loop ends |         |                |       |                                             |                      |

✅ Result:

```
[[-1, -1, 2], [-1, 0, 1]]
```

Excellent 👍 — this will be a complete interview-ready study sheet for arrays + strings medium problems.

Because all 10 problems include —
✅ full explanation,
✅ input/output,
✅ Java code,
✅ and full tracing —
the total content is long.

👉 I’ll send it in 10 parts (1 per problem) to keep it clean and readable.
We’ve already done 1 (3Sum).
Let’s now continue with the remaining 2 → 10, one by one.



 🧠 2️⃣ Problem: Longest Substring Without Repeating Characters

LeetCode 3



 🔹 Problem Statement

Given a string `s`, find the length of the longest substring without repeating characters.



 🔹 Example

Input:
`s = "abcabcbb"`
Output:
`3`

Explanation:
The longest substring without repeating characters is `"abc"`, which has length 3.



 🔹 Intuition

We need to find a substring (continuous part of the string) where all characters are unique.

✅ Sliding Window technique is perfect here:

* Use two pointers → `left` and `right`
* Use a `Set` or `Map` to track seen characters
* Move `right` forward; if you find a duplicate, move `left` until it’s unique again



 🔹 Java Solution

```java
import java.util.*;

public class LongestUniqueSubstring {
    public static int lengthOfLongestSubstring(String s) {
        Set<Character> seen = new HashSet<>();
        int left = 0, maxLen = 0;

        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);

            // Remove from left until no duplicate
            while (seen.contains(c)) {
                seen.remove(s.charAt(left));
                left++;
            }

            seen.add(c);
            maxLen = Math.max(maxLen, right - left + 1);
        }

        return maxLen;
    }

    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb")); // Output: 3
    }
}
```



 🔹 Step-by-Step Trace

| Step | Left | Right | Substring                                  | Action                                      | Max |
| - | - | -- |  | - |  |
| 1    | 0    | 0     | "a"                                        | add 'a'                                     | 1   |
| 2    | 0    | 1     | "ab"                                       | add 'b'                                     | 2   |
| 3    | 0    | 2     | "abc"                                      | add 'c'                                     | 3   |
| 4    | 0    | 3     | "abca"                                     | 'a' repeats → remove left → substring "bca" | 3   |
| 5    | 1    | 4     | "bcab"                                     | 'b' repeats → remove 'b' → substring "cab"  | 3   |
| 6    | 2    | 5     | "cabc" → 'c' repeats → remove left → "abc" | 3                                           |     |

✅ Final answer = `3`


 Problem: Longest Palindromic Substring
LeetCode 5

Problem Statement
Find the longest palindromic substring in a given string `s`.



 🔹 Example

Input:
`s = "babad"`
Output:
`"bab"` (or `"aba"`)

Explanation:
Both `"bab"` and `"aba"` are palindromes.



 🔹 Intuition

Expand from center:

* A palindrome mirrors around its center.
* For each index, expand for both:

  * Odd-length (`center = i`)
  * Even-length (`center between i and i+1`)



 🔹 Java Solution

```java
public class LongestPalindromeSubstring {
    private static int start = 0, maxLen = 0;

    public static String longestPalindrome(String s) {
        for (int i = 0; i < s.length(); i++) {
            expand(s, i, i);     // odd
            expand(s, i, i + 1); // even
        }
        return s.substring(start, start + maxLen);
    }

    private static void expand(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        int len = right - left - 1;
        if (len > maxLen) {
            start = left + 1;
            maxLen = len;
        }
    }

    public static void main(String[] args) {
        System.out.println(longestPalindrome("babad")); // Output: bab or aba
    }
}
```



 🔹 Trace

```
i=0 → expand("b","b") → palindrome "b"
i=1 → expand("a","a") → palindrome "bab"
i=2 → expand("b","b") → palindrome "aba"
Longest = "bab"
```

✅ Output: `"bab"`



 1️⃣ String Compression

LeetCode 443

🧩 Problem:
You are given a character array `chars`. Compress it using the following rules:

* Replace sequences of the same character by the character followed by the count.
* Compression is done in-place.

🔹 Input:
`['a','a','b','b','c','c','c']`

🔹 Output:
`['a','2','b','2','c','3']` (length = 6)

🧠 Explanation:

* Two-pointer method — one pointer reads the string, another writes compressed characters.

🧾 Java Code:

```java
class Solution {
    public int compress(char[] chars) {
        int index = 0, i = 0;
        while (i < chars.length) {
            char currentChar = chars[i];
            int count = 0;
            while (i < chars.length && chars[i] == currentChar) {
                i++;
                count++;
            }
            chars[index++] = currentChar;
            if (count > 1) {
                for (char c : String.valueOf(count).toCharArray()) {
                    chars[index++] = c;
                }
            }
        }
        return index;
    }
}
```

🔍 Trace:
`aabbccc` → `a2b2c3` → length = 6


 2️⃣ Implement strStr() (Substring Search)

LeetCode 28

🧩 Problem:
Return the index of the first occurrence of substring `needle` in `haystack`, or `-1` if not found.

🔹 Input:
`haystack = "sadbutsad", needle = "sad"`

🔹 Output:
`0`

🧠 Explanation:
Use the sliding window technique to match substrings.

🧾 Java Code:

```java
class Solution {
    public int strStr(String haystack, String needle) {
        for (int i = 0; i <= haystack.length() - needle.length(); i++) {
            if (haystack.substring(i, i + needle.length()).equals(needle)) {
                return i;
            }
        }
        return -1;
    }
}
```

🔍 Trace:
Compare windows of size `needle.length()` until match found.



 3️⃣ Valid Parentheses

LeetCode 20

🧩 Problem:
Given a string of parentheses, determine if it's valid.
Valid means every opening bracket has a closing bracket in correct order.

🔹 Input:
`"()[]{}"`

🔹 Output:
`true`

🧠 Explanation:
Use a stack to push opening brackets and pop when closing brackets match.

🧾 Java Code:

```java
import java.util.*;

class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(') stack.push(')');
            else if (c == '{') stack.push('}');
            else if (c == '[') stack.push(']');
            else if (stack.isEmpty() || stack.pop() != c) return false;
        }
        return stack.isEmpty();
    }
}
```

🔍 Trace:
`"([{}])"` → push/pop each → ✅ valid



 4️⃣ Longest Common Prefix

LeetCode 14

🧩 Problem:
Find the longest common prefix among an array of strings.

🔹 Input:
`["flower","flow","flight"]`

🔹 Output:
`"fl"`

🧠 Explanation:
Compare prefixes character by character.

🧾 Java Code:

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) return "";
            }
        }
        return prefix;
    }
}
```

🔍 Trace:
Compare `"flower"` and `"flow"` → `"flow"` → then `"fl"` with `"flight"` → `"fl"`



 5️⃣ Decode String

LeetCode 394

🧩 Problem:
Given a string encoded like `3[a2[c]]`, decode it to `"accaccacc"`.

🔹 Input:
`"3[a2[c]]"`

🔹 Output:
`"accaccacc"`

🧠 Explanation:
Use two stacks — one for numbers and one for strings.
Decode nested patterns like `[ ]`.

🧾 Java Code:

```java
import java.util.*;

class Solution {
    public String decodeString(String s) {
        Stack<Integer> counts = new Stack<>();
        Stack<String> resultStack = new Stack<>();
        String result = "";
        int i = 0;

        while (i < s.length()) {
            if (Character.isDigit(s.charAt(i))) {
                int count = 0;
                while (Character.isDigit(s.charAt(i))) {
                    count = 10 * count + (s.charAt(i) - '0');
                    i++;
                }
                counts.push(count);
            } else if (s.charAt(i) == '[') {
                resultStack.push(result);
                result = "";
                i++;
            } else if (s.charAt(i) == ']') {
                StringBuilder temp = new StringBuilder(resultStack.pop());
                int count = counts.pop();
                for (int j = 0; j < count; j++) temp.append(result);
                result = temp.toString();
                i++;
            } else {
                result += s.charAt(i++);
            }
        }
        return result;
    }
}
```

🔍 Trace:
`3[a2[c]]`
→ process `a2[c]` → `acc`
→ repeat 3 times → `accaccacc`
