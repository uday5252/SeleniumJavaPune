MINIMUM OPERATIONS TO HALVE ARRAY SUM

class Solution {
    public int halveArray(int[] nums) {
        
        double initialTotalArraySum = 0;

        PriorityQueue<Double> maxHeap = new PriorityQueue<Double>(Collections.reverseOrder());
        
        for( double i : nums)
        {
            initialTotalArraySum += i;
            maxHeap.add(i);
        }

        double initialTotalArraySumHalf = initialTotalArraySum / 2;
        double newHeapArraySum = 0.0; //9.5 + 4.75 ==> 14.25 + 4 => 18.25
        // [19.0, 5.0, 8.0, 1.0]

        int operationCount = 0;

        while(newHeapArraySum < initialTotalArraySumHalf)
        {
            double maxElement = maxHeap.poll();
            maxHeap.add(maxElement / 2);
            newHeapArraySum = newHeapArraySum + maxElement / 2;
            operationCount++;
            System.out.println(operationCount);
        }

        return operationCount;
    }
}
============================
MEDIAN IN A DATA STREAM

class MedianFinder {

    // maxHeap stores the smaller half (largest element on top)
    PriorityQueue<Integer> maxHeap;

    // minHeap stores the larger half (smallest element on top)
    PriorityQueue<Integer> minHeap;

    public MedianFinder() {
        // maxHeap = reverse order (acts like max-heap)
        maxHeap = new PriorityQueue<>(Collections.reverseOrder());

        // minHeap = normal heap (min-heap)
        minHeap = new PriorityQueue<>();
    }

 public void addNum(int num) {

        // Step 1: Insert into correct heap
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {
            maxHeap.add(num); // smaller elements
        } else {
            minHeap.add(num); // larger elements
        }

        // Step 2: Balance both heaps (difference should not exceed 1)
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.add(maxHeap.poll()); // move one from maxHeap -> minHeap
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.add(minHeap.poll()); // move one from minHeap -> maxHeap
        }
    }

  public double findMedian() {
        // If equal size, median = average of two middle values
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }

        // Else maxHeap has the extra element
        return maxHeap.peek();
    }
